## What
Git hooks就是Git在特定事件（比如commit、push、receive）发生之前或者之后执行的脚本。类似于监听器、触发器这样的功能。==[官方文档](https://git-scm.com/docs/githooks)==
按照Git hooks脚本所在的位置可以分为：
1. 本地Hooks或者说客户端Hooks：可以触发的事件如commit，merge
2. 服务端Hooks：可以触发的时间比如receive



## 可以实现什么功能？
每一个Git项目下都包含有.git/hooks 这个目录（本地和远程都是这样，把后缀.sample去掉，或者用列表中的名字新建一个文件，就可以把该脚本激活 绑定到特定的git行为上），这里面就是放置Hooks的地方。你可以在这个目录下自由定制Hooks的功能，实际工作中可以实现的功能比如：
-   pre-commit: 检查每次的commit message是否有拼写错误，或是否符合某种规范。
-   pre-receive: 统一上传到远程库的代码的编码。
-   post-receive: 每当有新的提交的时候就通知项目成员（可以使用Email或SMS等方式）。
-   post-receive: 把代码推送到生产环境。 
-   etc...

### 客户端钩子
- **[pre-commit](pre-commit.md)（常用）**
	- 在提交一个commit之前， **它用于检查即将提交的commit**。以确保这份提交中没有缺少什么东西、文件名是否符合规范、是否对这份提交进行了测试、代码风格是否符合团队要求等等。 这个脚本可以通过传递--no-verify参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。  
- prepare-commit-msg
	- 脚本会在默认的提交信息准备完成后但编辑器尚未启动之前运行。 这个脚本的作用是用来编辑commit的默认提交说明。 该脚本有1~3个参数：包含提交说明文件的路径，commit类型（message, template, merge, squash），一个用于commit的SHA1值。这个脚本用的机会不是太多，主要是用于能自动生成commit message的情况。 不会因为--no-verify参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。
	- 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。
- commit-msg（常用）
	- 包含有一个参数：用来规定提交说明文件的路径。 该脚本可以用来验证提交说明的规范性，如果作者写的提交说明不符合指定路径文件中的规范，提交就会被终止。 该脚本可以通过传递--no-verify参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。  
- post-commit  
	- 脚本发生在整个提交过程完成之后。这个脚本不包含任何参数，也不会影响commit的运行结果，可以用于发送new commit通知。
-   E-mail Hooks  
    与git am 相关的脚本由三个，均由git am  触发运行，按顺序依次是：  
    applypatch-msg  pre-applypatch  post-applypaych
    如果在工作流中用不到这个命令，那也就无所谓了。不过，如果要用git format-patch命令通过Email提交补丁，这部分内容还是比较有用的。  
- applypatch-msg  
	- 脚本最先被触发，它包含一个参数，用来规定提交说明文件的路径。该脚本可以修改文件中保存的提交说明，以便规范提交说明以符合项目标准。如果提交说明不符合规定的标准，脚本返回非零值，git终止提交。  
	- 说明一点，这个脚本看上去和commit-msg作用几乎一样。也就是说，该脚本会调用commit-msg并执行。实际上，这一切都是可修改的。  
- pre-applypatch  
	- 会在补丁应用后但尚未提交前运行。这个脚本没有参数，可以用于对应用补丁后的工作区进行测试，或对git tree进行检查。如果不能通过测试或检查，脚本返回非零值，git终止提交。 同样需要注意，git提供的此默认脚本中只是简单调用了pre-commit，因此在实际工作中需要视情况修改。  
- post-applypatch  
	- 脚本会在补丁应用并提交之后运行，它不包含参数，也不会影响git am的运行结果。该脚本可以用来向工作组成员或补丁作者发送通知。
	- 由git rebase  命令调用，运行在rebase执行之前，可以用来阻止任何已发发生过的提交参与变基（字面意思，找不到合适的词汇了）。默认的pre-rebase确实是这么做的，不过脚本中的next是根据Git项目自身而写的分支名，在使用过程中应该将其改成自己的稳定分支名称。  
- post-checkout  
	- 由git checkout  命令调用，在完成工作区更新之后执行。该脚本由三个参数：之前HEAD指向的引用，新的HEAD指向的引用，一个用于标识此次检出是否是分支检出的值（0表示文件检出，1表示分支检出）。  也可以被git clone触发调用，除非在克隆时使用参数--no-checkout。在由clone调用执行时，三个参数分别为null, 1, 1。
	- 这个脚本可以用于为自己的项目设置合适的工作区，比如自动生成文档、移动一些大型二进制文件等，也可以用于检查版本库的有效性。  
- post-merge
	- 由git merge调用，在merge成功后执行。该脚本有一个参数，标识合并是否为压缩合并。该脚本可以用于对一些Git无法记录的数据的恢复，比如文件权限、属主、ACL等。 Server Side 除了本地执行的Hooks脚本之外，还有一些放在Git Server上的Hooks脚本，作为管理员，可以利用这些服务端的脚本来强制确保项目的任何规范。这些运行在服务端的脚本，会在push命令发生的前后执行。pre系列的脚本可以在任何时候返回非零值来终止某次push，并向push方返回一个错误

### 客户端Hooks缺陷
这些hooks脚本并不会通过clone传到项目中，不能和其他人共享，而且既然是完全运行在本地，那就无法完全保证验证能起到作用（可以随便修改），但为了保证一些项目的可靠性，需要开发者们自觉遵守这些规则。
针对这一问题，有两种可以指定Git Hooks的方式：[Husky](https://typicode.github.io/husky/#/)、[yorkie](https://github.com/yyx990803/yorkie)

## 服务端Hooks
- pre-receive
	- 处理来自客户端的推送操作时，最先被调用的脚本是 `pre-receive`。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。
- update
	- `update` 脚本和 `pre-receive` 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，`pre-receive` 只运行一次，相比之下 `update` 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。
- post-receive
	- `post-receive` 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 `pre-receive` 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器， 或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态， 所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。
